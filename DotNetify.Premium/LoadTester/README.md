<p align="center"><img width="350px" src="http://dotnetify.net/content/images/dotnetify-logo.png"></p>

[![NuGet](https://img.shields.io/nuget/v/DotNetify.LoadTester.svg?style=flat-square)](https://www.nuget.org/packages/DotNetify.LoadTester/)

## DotNetify-LoadTester

_DotNetify-LoadTester_ is a tool for authoring and running performance testing on your dotNetify application servers. It allows you to establish thousands of concurrent SignalR connections to your dotNetify hub and write tests that emulate how your application clients interact with the server-side view models.

#### Installation

Create a .NET Core test or console app project and add the following library from NuGet: **DotNetify.LoadTester**.

#### Basic Usage

Start by creating a new instance of **LoadTestBuilder** and configure the application server URL, the number of clients, and how each one will interact with your server-side view model:

```csharp
var builder = new LoadTestBuilder("https://my-app.io")
  .AddClient(5, (client, index) =>
  {
    client.Connect(nameof(HelloWorldVM));
  });
```

The **AddClient** method allows to configure the behaviors of each client through the delegate argument of type `ILoadTestClientBuilder`. In the above example, all clients will attempt to connect to the _HelloWorldVM_ view model at the specified URL when the test commences. And just as the real API, you can pass connect options to the **Connect** method.

Run the load test by calling the **RunAsync** method with the run duration as its argument:

```csharp
await builder.RunAsync(TimeSpan.FromMinutes(5));
```

You can configure how fast the clients get added or disposed with the **SetRampUpPeriod** and **SetRampDownPeriod** methods:

```csharp
await builder
  .SetRampUpPeriod(TimeSpan.FromSeconds(30))
  .SetRampDownPeriod(TimeSpan.FromSeconds(30))
  .RunAsync(TimeSpan.FromMinutes(5));
```

Without the configuration, the interval defaults to 100 milliseconds between clients.

#### Logging

It's always a good idea to pass a logger so you can access the information generated by the test runner such as when the clients are connecting, when they are being disposed, or if there are connection errors:

```csharp
ILogger logger = LoggerFactory
  .Create(builder => builder.AddConsole())
  .CreateLogger("MyLoadTest");

await builder
  .SetLogger(logger)
  .RunAsync(TimeSpan.FromMinutes(5));
```

#### Client Dispatch

To get the clients to dispatch data following a successful connection, use the **Dispatch** method. You can specify the frequency, either once or repeating with time delay in milliseconds, and use the **Wait** method to add delay between different dispatches:

```csharp
var builder = new LoadTestBuilder("https://my-app.io")
  .AddClient(5, (client, index) =>
  {
    client
      .Connect(nameof(HelloWorldVM))
      .Dispatch(new { Greetings = "Hello" }).Once()
      .Wait(5000)
      .Dispatch(new { Greetings = "World" }).Repeat(3, 1000);
  });
```

The **Dispatch** method has an overload that allows you to pass a callback function to build the dispatch payload at runtime:

```csharp
   client.Dispatch(_ => new { Time = DateTime.Now }).RepeatContinuosly(1000);
```

#### Handling Server Responses

When you want to inspect the responses a client receives, and perhaps perform dispatches according to those responses, use the **OnServerResponse** method:

```csharp
   client
    .Connect(nameof(EchoVM))
    .OnServerResponse((vm, response) =>
    {
      var deserializedResponse = response.As<EchoPing>();
      vm.Dispatch(new { Pong = deserializedResponse.Ping.Time });
    });
```

The method parameter is an action delegate which passes two arguments: an object of type `IClientVM` that will allow you to perform a dispatch, and the server response itself, wrapped in an object of type `ServerResponse`. You can access the raw data directly, or use a convenient **As** method to deserialize the data into a strongly-typed object.

#### Client Destroy

To remove a client's connection to the view model, use the **Destroy** method provided by both the `ILoadTestClientBuilder` and the `IClientVM` types.

To receive callback when the event occurs, use the **OnDestroyed** method of `ILoadTestClientBuilder`.
